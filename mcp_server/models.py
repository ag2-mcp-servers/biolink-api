# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T06:58:08+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel


class APageOfResults(BaseModel):
    page: Optional[int] = Field(None, description='Number of this page of results')
    pages: Optional[int] = Field(None, description='Total number of pages of results')
    per_page: Optional[int] = Field(
        None, description='Number of items per page of results'
    )
    total: Optional[int] = Field(None, description='Total number of results')


class AbstractPropertyValue(BaseModel):
    pred: Optional[str] = Field(None, description='predicate (attribute) part')
    val: Optional[str] = Field(None, description='value part')
    xrefs: Optional[List[str]] = Field(
        None, description='Xrefs provenance for property-value'
    )


class AutocompleteResult(BaseModel):
    category: Optional[List[str]] = Field(None, description='node categories')
    equivalent_ids: Optional[List[str]] = Field(None, description='Equivalent IDs')
    has_highlight: Optional[bool] = Field(
        None, description='True if highlight can be interpreted as html, else False'
    )
    highlight: Optional[str] = Field(None, description='solr highlight')
    id: Optional[str] = Field(None, description='curie formatted id')
    label: Optional[List[str]] = Field(None, description='primary label (rdfs:label)')
    match: Optional[str] = Field(
        None,
        description='matched part of document (may be primary label, synonym, id, etc)',
    )
    taxon: Optional[str] = Field(None, description='taxon as NCBITaxon curie')
    taxon_label: Optional[str] = Field(None, description='taxon label')


class AutocompleteResults(BaseModel):
    docs: Optional[List[AutocompleteResult]] = Field(
        None, description='list of AutocompleteResult docs'
    )


class CompactAssociationSet(BaseModel):
    objects: List[str] = Field(
        ...,
        description='List of O, for a given (S,R) pair, yielding (S,R,O) triples. E.g. list of MPs for (MGI:nnn, has_phenotype)',
    )
    relation: str = Field(
        ..., description='Relationship type connecting subject and object list'
    )
    subject: str = Field(
        ..., description='Subject of association (what it is about), e.g. MGI:1201606'
    )


class CompareInput(BaseModel):
    query_ids: Optional[List[List[str]]] = Field(
        None, description='list of query profiles'
    )
    reference_ids: Optional[List[str]] = Field(None, description='list of ids')


class Edge(BaseModel):
    meta: Optional[Dict[str, Any]] = Field(None, description='metadata about the Edge')
    obj: Optional[str] = Field(None, description='Object (target) Node ID')
    pred: Optional[str] = Field(None, description='Predicate (relation) ID')
    sub: Optional[str] = Field(None, description='Subject (source) Node ID')


class EntityReference(BaseModel):
    id: Optional[str] = Field(None, description='ID or CURIE e.g. MGI:1201606')
    label: Optional[str] = Field(None, description='RDFS Label')


class Feature(BaseModel):
    id: Optional[str] = Field(None, description='curie formatted id')
    isPresent: Optional[bool] = Field(None, description='is the feature present')
    label: Optional[str] = Field(None, description='curie formatted id')
    type: Optional[str] = Field(
        None, description='feature type (only phenotype supported)'
    )


class LayAutocomplete(BaseModel):
    highlight: Optional[str] = Field(None, description='solr highlight')
    id: Optional[str] = Field(None, description='curie formatted id')
    label: Optional[str] = Field(None, description='primary label (rdfs:label)')
    matched_synonym: Optional[str] = Field(None, description='matched synonym')


class LayResults(BaseModel):
    results: Optional[List[LayAutocomplete]] = Field(
        None, description='list of AutocompleteResult docs'
    )


class NamedObjectCore(BaseModel):
    category: Optional[List[str]] = None
    id: str = Field(..., description='ID or CURIE e.g. MGI:1201606')
    iri: Optional[str] = Field(None, description='IRI')
    label: Optional[str] = Field(None, description='RDFS Label')


class Node(BaseModel):
    id: str = Field(..., description='ID or CURIE e.g. MGI:1201606')
    label: Optional[str] = Field(None, description='RDFS Label')


class RelationRef(NamedObjectCore):
    inverse: Optional[bool] = Field(False, description='is relation inverted')


class SearchResult(BaseModel):
    docs: Optional[List[Dict[str, Any]]] = Field(None, description='solr docs')
    facet_counts: Optional[Dict[str, Any]] = Field(
        None, description='Mapping between field names and association counts'
    )
    highlighting: Optional[Dict[str, Any]] = Field(
        None, description='Mapping between id and solr highlight'
    )
    numFound: Optional[int] = Field(
        None, description='total number of associations matching query'
    )


class SequencePosition(BaseModel):
    position: Optional[int] = None
    reference: Optional[str] = None


class SimMetadata(BaseModel):
    max_max_ic: Optional[float] = Field(None, description='max IC')


class SufficiencyOutput(BaseModel):
    categorical_score: Optional[float] = Field(None, description='categorical score')
    scaled_score: Optional[float] = Field(None, description='scaled score')
    simple_score: Optional[float] = Field(None, description='simple score')


class SufficiencyPostInput(BaseModel):
    features: Optional[List[Feature]] = Field(None, description='list of features')
    id: Optional[str] = Field(None, description='curie formatted id')


SynonymPropertyValue = AbstractPropertyValue


class Taxon(BaseModel):
    id: Optional[str] = Field(None, description='CURIE ID, e.g. NCBITaxon:9606')
    label: Optional[str] = Field(None, description='RDFS Label')


class Token(BaseModel):
    categories: Optional[List[str]] = Field(None, description='entity categories')
    id: Optional[str] = Field(None, description='The CURIE for the entity or token')
    terms: Optional[List[str]] = Field(None, description='terms')


class TypedNode(Node):
    taxon: Optional[Node] = Field(None, description='taxon')
    type: Optional[str] = Field(None, description='node type (eg phenotype, disease)')


class Mme(BaseModel):
    pass


class VariantSet(BaseModel):
    body: str = Field(..., description='Article content')
    category: Optional[str] = None
    category_id: Optional[int] = None
    id: Optional[int] = Field(
        None, description='The unique identifier of a variant set'
    )
    pub_date: Optional[datetime] = None
    title: str = Field(..., description='Article title')


class FacetFields(RootModel[List[str]]):
    root: List[str]


class Slim(RootModel[List[str]]):
    root: List[str]


class Taxon1(RootModel[List[str]]):
    root: List[str]


class AssociationType(Enum):
    causal = 'causal'
    non_causal = 'non_causal'
    both = 'both'


class Evidence(RootModel[List[str]]):
    root: List[str]


class RelationshipType(Enum):
    involved_in = 'involved_in'
    involved_in_regulation_of = 'involved_in_regulation_of'
    acts_upstream_of_or_within = 'acts_upstream_of_or_within'


class HomologyType(Enum):
    P = 'P'
    O = 'O'
    LDO = 'LDO'


class Type(Enum):
    gene = 'gene'
    variant = 'variant'
    genotype = 'genotype'
    phenotype = 'phenotype'
    disease = 'disease'
    goterm = 'goterm'
    pathway = 'pathway'
    anatomy = 'anatomy'
    substance = 'substance'
    individual = 'individual'
    publication = 'publication'
    model = 'model'
    case = 'case'


class Subject(RootModel[List[str]]):
    root: List[str]


class Background(RootModel[List[str]]):
    root: List[str]


class RelationshipType4(Enum):
    involved_in = 'involved_in'
    acts_upstream_of_or_within = 'acts_upstream_of_or_within'


class Direction(Enum):
    INCOMING = 'INCOMING'
    OUTGOING = 'OUTGOING'
    BOTH = 'BOTH'


class Graph1(Enum):
    data = 'data'
    ontology = 'ontology'


class RelationshipType6(RootModel[List[str]]):
    root: List[str]


class IncludeCategory(RootModel[List[str]]):
    root: List[str]


class ExcludeCategory(RootModel[List[str]]):
    root: List[str]


class Label(RootModel[List[str]]):
    root: List[str]


class Id(RootModel[List[str]]):
    root: List[str]


class Cnode(RootModel[List[str]]):
    root: List[str]


class Relation1(RootModel[List[str]]):
    root: List[str]


class GraphType(Enum):
    topology_graph = 'topology_graph'
    regulates_transitivity_graph = 'regulates_transitivity_graph'
    neighborhood_graph = 'neighborhood_graph'
    neighborhood_limited_graph = 'neighborhood_limited_graph'


class Fq(RootModel[List[str]]):
    root: List[str]


class Category(RootModel[List[str]]):
    root: List[str]


class Prefix(RootModel[List[str]]):
    root: List[str]


class BoostFx(RootModel[List[str]]):
    root: List[str]


class BoostQ(RootModel[List[str]]):
    root: List[str]


class Metric(Enum):
    phenodigm = 'phenodigm'
    jaccard = 'jaccard'
    simGIC = 'simGIC'
    resnik = 'resnik'
    symmetric_resnik = 'symmetric_resnik'


class RefId(RootModel[List[str]]):
    root: List[str]


class QueryId(RootModel[List[str]]):
    root: List[str]


class AbsentId(RootModel[List[str]]):
    root: List[str]


class PerPage(Enum):
    integer_2 = 2
    integer_10 = 10
    integer_20 = 20
    integer_30 = 30
    integer_40 = 40
    integer_50 = 50


class BioObjectCore(NamedObjectCore):
    taxon: Optional[Taxon] = Field(
        None, description='Taxon to which the object belongs'
    )


class Graph(BaseModel):
    edges: Optional[List[Edge]] = Field(None, description='All edges in graph')
    nodes: Optional[List[Node]] = Field(None, description='All nodes in graph')


class IcNode(Node):
    IC: Optional[float] = Field(None, description='Information content')


class NamedObject(NamedObjectCore):
    consider: Optional[List[str]] = None
    deprecated: Optional[bool] = Field(
        None, description='True if the node is deprecated/obsoleted.'
    )
    description: Optional[str] = Field(
        None,
        description='Descriptive text for the entity. For ontology classes, this will be a definition.',
    )
    replaced_by: Optional[List[str]] = None
    synonyms: Optional[List[SynonymPropertyValue]] = Field(
        None, description='list of synonyms or alternate labels'
    )
    types: Optional[List[str]] = None


class PageOfVariantSets(APageOfResults):
    items: Optional[List[VariantSet]] = None


class PairwiseMatch(BaseModel):
    lcs: Optional[IcNode] = Field(None, description='lowest common subsumer')
    match: Optional[IcNode] = Field(None, description='match id')
    reference: Optional[IcNode] = Field(None, description='reference id')


Relation = NamedObject


class SimMatch(TypedNode):
    pairwise_match: Optional[List[PairwiseMatch]] = None
    rank: Optional[str] = Field(None, description='rank')
    score: Optional[float] = Field(None, description='sim score')
    significance: Optional[str] = Field(None, description='p-value')


class SimQuery(BaseModel):
    ids: Optional[List[Node]] = None
    negated_ids: Optional[List[Node]] = None
    reference: Optional[TypedNode] = Field(
        None, description='reference individual or class (eg gene, disease)'
    )
    target_ids: Optional[List[List[Node]]] = None
    unresolved_ids: Optional[List[str]] = Field(
        None, description='list of unresolved ids'
    )


class SimResult(BaseModel):
    matches: Optional[List[SimMatch]] = None
    metadata: Optional[SimMetadata] = None
    query: Optional[SimQuery] = None


class Span(BaseModel):
    end: Optional[int] = Field(None, description='end of span text relative to content')
    start: Optional[int] = Field(
        None, description='start of span text relative to content'
    )
    text: Optional[str] = Field(None, description='span text')
    token: Optional[List[Token]] = Field(
        None, description='A token or entity extracted from the span text'
    )


class BioentityPhenotypeIdAnatomyGetResponse(RootModel[List[NamedObject]]):
    root: List[NamedObject]


class EvidenceGraphIdGetResponse(RootModel[List[Graph]]):
    root: List[Graph]


class GraphEdgesFromIdGetResponse(RootModel[List[Graph]]):
    root: List[Graph]


class AnnotationExtension(BaseModel):
    filler: Optional[NamedObject] = Field(
        None,
        description='Extension interpreted as OWL expression (r1 some r2 some .. some filler).',
    )
    relation_chain: Optional[List[Relation]] = Field(
        None,
        description='Relationship type. If more than one value, interpreted as chain',
    )


class Association(BaseModel):
    evidence_graph: Optional[Graph] = Field(
        None,
        description='An indirect association is a join between two or more direct assocations, e.g. gene to disease via ortholog. We record the full set of associations as a graph object',
    )
    evidence_types: Optional[List[EntityReference]] = Field(
        None, description='Evidence types (ECO classes)'
    )
    id: str = Field(..., description='Association/annotation unique ID')
    negated: Optional[bool] = Field(None, description='True if association is negated')
    object: BioObjectCore = Field(
        ...,
        description='Object (sensu RDF), aka target, e.g. HP:0000448, MP:0002109, DOID:14330',
    )
    object_eq: Optional[List[str]] = Field(
        None, description='Equivalent identifiers to object node'
    )
    object_extensions: Optional[List[AnnotationExtension]] = None
    provided_by: Optional[List[str]] = Field(
        None, description='Provider of association, e.g. Orphanet, ClinVar'
    )
    publications: Optional[List[EntityReference]] = Field(
        None,
        description='Publications supporting association, extracted from evidence graph',
    )
    qualifiers: Optional[List[str]] = Field(
        None, description='Qualifier on the association'
    )
    relation: RelationRef = Field(
        ..., description='Relationship type connecting subject and object'
    )
    slim: Optional[List[str]] = Field(None, description='Objects mapped to a slim')
    subject: BioObjectCore = Field(
        ...,
        description='Subject of association (what it is about), e.g. ClinVar:nnn, MGI:1201606',
    )
    subject_eq: Optional[List[str]] = Field(
        None, description='Equivalent identifiers to subject node'
    )
    subject_extensions: Optional[List[AnnotationExtension]] = None
    type: Optional[str] = Field(
        None, description='Type of association, e.g. gene-phenotype'
    )


class AssociationResults(SearchResult):
    associations: Optional[List[Association]] = Field(
        None,
        description='Complete representation of full association object, plus evidence',
    )
    compact_associations: Optional[List[CompactAssociationSet]] = Field(
        None,
        description='Compact representation in which objects (e.g. phenotypes) are collected for subject-predicate pairs',
    )
    objects: Optional[List[str]] = Field(
        None, description='List of distinct objects used'
    )


class BioObject(NamedObject):
    association_counts: Optional[Dict[str, Any]] = Field(
        None, description='association counts'
    )
    taxon: Optional[Taxon] = Field(
        None, description='Taxon to which the object belongs'
    )
    xrefs: Optional[List[str]] = Field(
        None,
        description='Database cross-references. These are usually CURIEs, but may also be URLs. E.g. ENSEMBL:ENSG00000099940 ',
    )


class D2PAssociation(Association):
    frequency: Optional[EntityReference] = Field(
        None, description='Frequency of phenotype in patients with disease'
    )
    onset: Optional[EntityReference] = Field(
        None, description='Onset of phenotype in disease process'
    )


class D2PAssociationResults(SearchResult):
    associations: Optional[List[D2PAssociation]] = Field(
        None,
        description='Complete representation of full disease to phenotype association, plus evidence',
    )
    compact_associations: Optional[List[CompactAssociationSet]] = Field(
        None,
        description='Compact representation in which objects (e.g. phenotypes) are collected for subject-predicate pairs',
    )
    objects: Optional[List[str]] = Field(
        None, description='List of distinct objects used'
    )


class EntityAnnotationResult(BaseModel):
    content: Optional[str] = 'The content from which the entities are extracted from'
    spans: Optional[List[Span]] = Field(None, description='A marked-up span of text')


class Seq(BioObject):
    alphabet: Optional[str] = Field(None, description='one of: DNA, RNA or AA')
    md5checksum: Optional[str] = Field(None, description='checksum')
    residues: Optional[str] = Field(
        None, description='string representing sequence of residues'
    )
    seqlen: Optional[str] = Field(None, description='length of sequence')


class SequenceLocation(BioObject):
    end: Optional[SequencePosition] = None
    phase: Optional[int] = None
    score: Optional[int] = None
    start: Optional[SequencePosition] = None
    strand: Optional[int] = Field(
        None, description="Strand direction: 1=='+', -1=='-', 0 or null infers unknown."
    )


class AssociationBetweenSubjectObjectGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class AssociationFindSubjectCategoryGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class AssociationFindSubjectCategoryObjectCategoryGetResponse(
    RootModel[List[AssociationResults]]
):
    root: List[AssociationResults]


class AssociationFromSubjectGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class AssociationToObjectGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class AssociationTypeAssociationTypeGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class AssociationIdGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class BioentitySubstanceIdParticipantInGetResponse(RootModel[List[Association]]):
    root: List[Association]


class BioentitySubstanceIdRolesGetResponse(RootModel[List[Association]]):
    root: List[Association]


class BioentitysetAssociationsGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class BioentitysetHomologsGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class CamInstanceIdGetResponse(RootModel[List[Association]]):
    root: List[Association]


class EvidenceGraphIdTableGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class GraphNodeIdGetResponse(RootModel[List[BioObject]]):
    root: List[BioObject]


class IdentifierMapperSourceTargetGetResponse(RootModel[List[Association]]):
    root: List[Association]


class IndividualPedigreeIdGetResponse(RootModel[List[Association]]):
    root: List[Association]


class IndividualIdGetResponse(RootModel[List[Association]]):
    root: List[Association]


class OwlOntologyDlqueryQueryGetResponse(RootModel[List[Association]]):
    root: List[Association]


class OwlOntologySparqlQueryGetResponse(RootModel[List[Association]]):
    root: List[Association]


class RelationUsageGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class RelationUsageBetweenSubjectCategoryObjectCategoryGetResponse(
    RootModel[List[AssociationResults]]
):
    root: List[AssociationResults]


class RelationUsagePivotGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class RelationUsagePivotLabelGetResponse(RootModel[List[AssociationResults]]):
    root: List[AssociationResults]


class VariationSetAnalyzeIdGetResponse(RootModel[List[Association]]):
    root: List[Association]


class SequenceFeature(BioObject):
    homology_associations: Optional[List[Association]] = None
    locations: Optional[List[SequenceLocation]] = None
    seq: Optional[Seq] = None


class GenomeFeaturesWithinBuildReferenceBeginEndGetResponse(
    RootModel[List[SequenceFeature]]
):
    root: List[SequenceFeature]
