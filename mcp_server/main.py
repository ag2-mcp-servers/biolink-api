# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T06:58:08+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity

from models import (
    AbsentId,
    AssociationBetweenSubjectObjectGetResponse,
    AssociationFindSubjectCategoryGetResponse,
    AssociationFindSubjectCategoryObjectCategoryGetResponse,
    AssociationFromSubjectGetResponse,
    AssociationIdGetResponse,
    AssociationResults,
    AssociationToObjectGetResponse,
    AssociationType,
    AssociationTypeAssociationTypeGetResponse,
    AutocompleteResults,
    Background,
    BioentityPhenotypeIdAnatomyGetResponse,
    BioentitysetAssociationsGetResponse,
    BioentitysetHomologsGetResponse,
    BioentitySubstanceIdParticipantInGetResponse,
    BioentitySubstanceIdRolesGetResponse,
    BioObject,
    BoostFx,
    BoostQ,
    CamInstanceIdGetResponse,
    Category,
    Cnode,
    CompareInput,
    D2PAssociationResults,
    Direction,
    EntityAnnotationResult,
    Evidence,
    EvidenceGraphIdGetResponse,
    EvidenceGraphIdTableGetResponse,
    ExcludeCategory,
    FacetFields,
    Fq,
    GenomeFeaturesWithinBuildReferenceBeginEndGetResponse,
    Graph1,
    GraphEdgesFromIdGetResponse,
    GraphNodeIdGetResponse,
    GraphType,
    HomologyType,
    Id,
    IdentifierMapperSourceTargetGetResponse,
    IncludeCategory,
    IndividualIdGetResponse,
    IndividualPedigreeIdGetResponse,
    Label,
    LayResults,
    Metric,
    Mme,
    OwlOntologyDlqueryQueryGetResponse,
    OwlOntologySparqlQueryGetResponse,
    PageOfVariantSets,
    PerPage,
    Prefix,
    QueryId,
    RefId,
    Relation1,
    RelationshipType,
    RelationshipType4,
    RelationshipType6,
    RelationUsageBetweenSubjectCategoryObjectCategoryGetResponse,
    RelationUsageGetResponse,
    RelationUsagePivotGetResponse,
    RelationUsagePivotLabelGetResponse,
    SearchResult,
    SimResult,
    Slim,
    Subject,
    SufficiencyOutput,
    SufficiencyPostInput,
    Taxon1,
    Type,
    VariantSet,
    VariationSetAnalyzeIdGetResponse,
)

app = MCPProxy(
    description='API integration layer for linked biological objects.\n\n __Source:__ https://github.com/biolink/biolink-api/',
    license={'name': 'BSD3'},
    title='BioLink API',
    version='1.1.14',
    servers=[{'url': '/api'}],
)


@app.get(
    '/association/between/{subject}/{object}',
    description=""" Given two entities (e.g. a particular gene and a particular disease), if these two entities
are connected (directly or indirectly), then return the association objects describing
the connection. """,
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
    ],
)
def get_associations_between(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    evidence: Optional[str] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    object: str = ...,
    subject: str = ...,
):
    """
    Returns associations connecting two entities
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/association/find/{subject_category}',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
    ],
)
def get_association_by_subject_category_search(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    evidence: Optional[str] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    subject_taxon: Optional[str] = None,
    object_taxon: Optional[str] = None,
    relation: Optional[str] = None,
    subject_category: str = ...,
):
    """
    Returns list of matching associations for a given subject category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/association/find/{subject_category}/{object_category}',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
    ],
)
def get_association_by_subject_and_object_category_search(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    evidence: Optional[str] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    subject: Optional[str] = None,
    object: Optional[str] = None,
    subject_taxon: Optional[str] = None,
    object_taxon: Optional[str] = None,
    relation: Optional[str] = None,
    object_category: str = ...,
    subject_category: str = ...,
):
    """
    Returns list of matching associations between a given subject and object category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/association/from/{subject}',
    tags=[
        'association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
        'generic_association_handling',
    ],
)
def get_associations_from(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    evidence: Optional[str] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    object_taxon: Optional[str] = None,
    relation: Optional[str] = None,
    subject: str = ...,
):
    """
    Returns list of matching associations starting from a given subject (source)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/association/to/{object}',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
    ],
)
def get_associations_to(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    evidence: Optional[str] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    object: str = ...,
):
    """
    Returns list of matching associations pointing to a given object (target)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/association/type/{association_type}',
    tags=['association_retrieval', 'generic_association_handling'],
)
def get_association_by_subject_and_assoc_type(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    evidence: Optional[str] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    subject: Optional[str] = None,
    object: Optional[str] = None,
    association_type: str = ...,
):
    """
    Returns list of matching associations of a given type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/association/{id}',
    description=""" An association connects, at a minimum, two things, designated subject and object,
via some relationship. Associations also include evidence, provenance etc. """,
    tags=['generic_association_handling', 'association_retrieval'],
)
def get_association_object(id: str):
    """
    Returns the association with a given identifier
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/anatomy/{id}/genes',
    tags=[
        'gene_association_retrieval',
        'case_association_management',
        'gene_associations_overview',
    ],
)
def get_anatomy_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genes associated with a given anatomy
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/anatomy/{id}/genes/{taxid}',
    description=""" For example, + NCBITaxon:10090 (mouse) """,
    tags=[
        'gene_association_retrieval',
        'case_association_management',
        'gene_associations_overview',
    ],
)
def get_anatomy_gene_by_taxon_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    taxid: str = ...,
    id: str = ...,
):
    """
    Returns gene IDs for all genes associated with a given anatomy, filtered by taxon
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/case/{id}/diseases',
    tags=['case_association_management', 'disease_association_retrieval'],
)
def get_case_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns diseases associated with a case
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/case/{id}/genotypes',
    tags=[
        'case_association_management',
        'gene_association_retrieval',
        'genotype_association_overview',
    ],
)
def get_case_genotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns genotypes associated with a case
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/case/{id}/models',
    tags=[
        'association_retrieval',
        'case_association_management',
        'model_association_collection',
        'gene_associations_overview',
    ],
)
def get_case_model_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns models associated with a case
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/case/{id}/phenotypes',
    tags=[
        'case_association_management',
        'phenotype_association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
    ],
)
def get_case_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns phenotypes associated with a case
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/case/{id}/variants',
    tags=[
        'case_association_management',
        'variant_association_retrieval',
        'gene_association_retrieval',
    ],
)
def get_case_variant_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns variants associated with a case
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/cases',
    tags=['case_association_management', 'disease_association_retrieval'],
)
def get_disease_case_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns cases associated with a disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/genes',
    tags=[
        'disease_association_retrieval',
        'gene_association_retrieval',
        'case_association_management',
        'gene_associations_overview',
    ],
)
def get_disease_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    association_type: Optional[AssociationType] = 'both',
    id: str = ...,
):
    """
    Returns genes associated with a disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/genotypes',
    tags=[
        'disease_association_retrieval',
        'gene_association_retrieval',
        'genotype_association_overview',
    ],
)
def get_disease_genotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genotypes associated with a disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/models',
    description=""" In the association object returned, the subject will be the disease, and the object will be the model.
The model may be a gene or genetic element.

If the query disease is a general class, the association subject may be to a specific disease.

In some cases the association will be *direct*, for example if a paper asserts a genotype is a model of a disease.

In other cases, the association will be *indirect*, for
example, chaining over orthology. In these cases the chain
will be reflected in the *evidence graph*

* TODO: provide hook into owlsim for dynamic computation of models by similarity """,
    tags=[
        'association_retrieval',
        'case_association_management',
        'disease_association_retrieval',
        'model_association_collection',
    ],
)
def get_disease_model_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns associations to models of the disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/models/{taxon}',
    description=""" See /disease/<id>/models route for full details """,
    tags=[
        'disease_association_retrieval',
        'model_association_collection',
        'case_association_management',
        'gene_association_retrieval',
    ],
)
def get_disease_model_taxon_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: str = ...,
    id: str = ...,
):
    """
    Returns associations to models of the disease constrained by taxon
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/pathways',
    tags=['disease_association_retrieval', 'pathway_association_retrieval'],
)
def get_disease_pathway_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns pathways associated with a disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/phenotypes',
    tags=[
        'case_association_management',
        'phenotype_association_retrieval',
        'disease_association_retrieval',
    ],
)
def get_disease_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns phenotypes associated with disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/publications',
    tags=['disease_association_retrieval', 'publication_association_retrieval'],
)
def get_disease_publication_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns publications associated with a disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/treatment',
    description=""" e.g. drugs or small molecules used to treat """,
    tags=[
        'association_retrieval',
        'disease_association_retrieval',
        'substance_association_details',
    ],
)
def get_disease_substance_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns substances associated with a disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/disease/{id}/variants',
    tags=[
        'disease_association_retrieval',
        'variant_association_retrieval',
        'case_association_management',
    ],
)
def get_disease_variant_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns variants associated with a disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/function/{id}',
    tags=[
        'function_association_management',
        'go_term_association_retrieval',
        'annotation_management_functions',
    ],
)
def get_function_associations(
    start: Optional[int] = 0,
    rows: Optional[int] = 100,
    evidence: Optional[Evidence] = None,
    id: str = ...,
):
    """
    Returns annotations associated to a function term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/function/{id}/genes',
    tags=[
        'go_term_association_retrieval',
        'gene_association_retrieval',
        'function_association_management',
    ],
)
def get_function_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    relationship_type: Optional[RelationshipType] = 'involved_in',
    id: str = ...,
):
    """
    Returns genes associated to a GO term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/function/{id}/publications',
    tags=[
        'go_term_association_retrieval',
        'publication_association_retrieval',
        'function_association_management',
    ],
)
def get_function_publication_associations(
    start: Optional[int] = 0,
    rows: Optional[int] = 100,
    evidence: Optional[Evidence] = None,
    id: str = ...,
):
    """
    Returns publications associated to a GO term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/function/{id}/taxons',
    tags=['function_association_management', 'go_term_association_retrieval'],
)
def get_function_taxon_associations(
    start: Optional[int] = 0,
    rows: Optional[int] = 100,
    evidence: Optional[Evidence] = None,
    id: str = ...,
):
    """
    Returns taxons associated to a GO term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/anatomy',
    tags=[
        'gene_association_retrieval',
        'gene_associations_overview',
        'case_association_management',
    ],
)
def get_gene_anatomy_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns anatomical entities associated with a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/cases',
    tags=[
        'case_association_management',
        'gene_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_gene_case_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns cases associated with a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/diseases',
    tags=[
        'disease_association_retrieval',
        'gene_association_retrieval',
        'case_association_management',
        'gene_associations_overview',
    ],
)
def get_gene_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    association_type: Optional[AssociationType] = 'both',
    id: str = ...,
):
    """
    Returns diseases associated with gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/expression/anatomy',
    tags=[
        'gene_association_retrieval',
        'gene_associations_overview',
        'annotation_management_functions',
    ],
)
def get_gene_expression_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns expression events for a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/function',
    description=""" IMPLEMENTATION DETAILS
----------------------

Note: currently this is implemented as a query to the GO/AmiGO solr instance.
This directly supports IDs such as:

 - ZFIN e.g. ZFIN:ZDB-GENE-050417-357

Note that the AmiGO GOlr natively stores MGI annotations to MGI:MGI:nn. However,
the standard for biolink is MGI:nnnn, so you should use this (will be transparently
mapped to legacy ID)

Additionally, for some species such as Human, GO has the annotation attached to the UniProt ID.
Again, this should be transparently handled; e.g. you can use NCBIGene:6469, and this will be
mapped behind the scenes for querying. """,
    tags=[
        'gene_association_retrieval',
        'case_association_management',
        'function_association_management',
        'gene_associations_overview',
    ],
)
def get_gene_function_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns function associations for a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/genotypes',
    tags=[
        'gene_association_retrieval',
        'gene_associations_overview',
        'genotype_association_overview',
    ],
)
def get_gene_genotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genotypes associated with a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/homologs',
    tags=['gene_association_retrieval', 'gene_associations_overview'],
)
def get_gene_homolog_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    homology_type: Optional[HomologyType] = None,
    direct_taxon: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns homologs for a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/interactions',
    tags=[
        'gene_association_retrieval',
        'gene_associations_overview',
        'association_retrieval',
    ],
)
def get_gene_interactions(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns interactions for a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/models',
    tags=[
        'gene_association_retrieval',
        'model_association_collection',
        'gene_associations_overview',
    ],
)
def get_gene_model_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns models associated with a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/ortholog/diseases',
    tags=[
        'disease_association_retrieval',
        'gene_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_gene_ortholog_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Return diseases associated with orthologs of a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/ortholog/phenotypes',
    tags=[
        'association_retrieval',
        'case_association_management',
        'gene_association_retrieval',
        'phenotype_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_gene_ortholog_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Return phenotypes associated with orthologs for a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/pathways',
    tags=[
        'gene_association_retrieval',
        'pathway_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_gene_pathway_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns pathways associated with gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/phenotypes',
    tags=[
        'gene_association_retrieval',
        'phenotype_association_retrieval',
        'case_association_management',
        'gene_associations_overview',
    ],
)
def get_gene_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns phenotypes associated with gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/publications',
    tags=[
        'gene_association_retrieval',
        'publication_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_gene_publication_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns publications associated with a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/gene/{id}/variants',
    tags=[
        'gene_association_retrieval',
        'variant_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_gene_variant_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns variants associated with a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/genotype/{id}/cases',
    tags=['case_association_management', 'genotype_association_overview'],
)
def get_genotype_case_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns cases associated with a genotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/genotype/{id}/diseases',
    tags=[
        'disease_association_retrieval',
        'genotype_association_overview',
        'case_association_management',
    ],
)
def get_genotype_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns diseases associated with a genotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/genotype/{id}/genes',
    tags=[
        'gene_association_retrieval',
        'genotype_association_overview',
        'gene_associations_overview',
        'case_association_management',
    ],
)
def get_genotype_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genes associated with a genotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/genotype/{id}/genotypes',
    description=""" Genotypes may be related to one another according to the GENO model """,
    tags=[
        'genotype_association_overview',
        'gene_association_retrieval',
        'case_association_management',
    ],
)
def get_genotype_genotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genotypes-genotype associations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/genotype/{id}/models',
    tags=[
        'genotype_association_overview',
        'model_association_collection',
        'gene_associations_overview',
        'case_association_management',
    ],
)
def get_genotype_model_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns models associated with a genotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/genotype/{id}/phenotypes',
    tags=[
        'gene_association_retrieval',
        'phenotype_association_retrieval',
        'genotype_association_overview',
    ],
)
def get_genotype_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns phenotypes associated with a genotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/genotype/{id}/publications',
    tags=[
        'genotype_association_overview',
        'publication_association_retrieval',
        'gene_association_retrieval',
    ],
)
def get_genotype_publication_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns publications associated with a genotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/genotype/{id}/variants',
    tags=[
        'genotype_association_overview',
        'variant_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_genotype_variant_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genotypes-variant associations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/goterm/{id}/genes',
    tags=[
        'go_term_association_retrieval',
        'function_association_management',
        'gene_association_retrieval',
    ],
)
def get_goterm_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    relationship_type: Optional[RelationshipType] = 'involved_in',
    id: str = ...,
):
    """
    Returns associations to GO terms for a gene
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/model/{id}/cases',
    tags=['case_association_management', 'model_association_collection'],
)
def get_model_case_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns cases associated with a model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/model/{id}/diseases',
    tags=['disease_association_retrieval', 'model_association_collection'],
)
def get_model_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns diseases associated with a model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/model/{id}/genes',
    tags=[
        'gene_association_retrieval',
        'model_association_collection',
        'gene_associations_overview',
    ],
)
def get_model_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genes associated with a model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/model/{id}/genotypes',
    tags=[
        'gene_association_retrieval',
        'genotype_association_overview',
        'model_association_collection',
    ],
)
def get_model_genotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genotypes associated with a model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/model/{id}/phenotypes',
    tags=[
        'phenotype_association_retrieval',
        'model_association_collection',
        'case_association_management',
    ],
)
def get_model_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns phenotypes associated with a model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/model/{id}/publications',
    tags=['publication_association_retrieval', 'model_association_collection'],
)
def get_model_publication_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns publications associated with a model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/model/{id}/variants',
    tags=[
        'variant_association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
        'model_association_collection',
        'gene_associations_overview',
    ],
)
def get_model_variant_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns variants associated with a model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/pathway/{id}/diseases',
    tags=['disease_association_retrieval', 'pathway_association_retrieval'],
)
def get_pathway_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns diseases associated with a pathway
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/pathway/{id}/genes',
    tags=[
        'gene_association_retrieval',
        'pathway_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_pathway_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genes associated with a pathway
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/pathway/{id}/phenotypes',
    tags=[
        'pathway_association_retrieval',
        'phenotype_association_retrieval',
        'association_retrieval',
    ],
)
def get_pathway_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns phenotypes associated with a pathway
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/anatomy',
    description=""" Example IDs:

 * MP:0008521 abnormal Bowman membrane """,
    tags=[
        'association_retrieval',
        'case_association_management',
        'phenotype_association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
    ],
)
def get_phenotype_anatomy_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns anatomical entities associated with a phenotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/cases',
    tags=[
        'case_association_management',
        'phenotype_association_retrieval',
        'gene_association_retrieval',
    ],
)
def get_phenotype_case_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns cases associated with a phenotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/diseases',
    tags=[
        'case_association_management',
        'disease_association_retrieval',
        'phenotype_association_retrieval',
    ],
)
def get_phenotype_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns diseases associated with a phenotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/gene/{taxid}/ids',
    description=""" For example, MP:0001569 + NCBITaxon:10090 (mouse) """,
    tags=[
        'gene_association_retrieval',
        'phenotype_association_retrieval',
        'case_association_management',
    ],
)
def get_phenotype_gene_by_taxon_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxid: str = ...,
    id: str = ...,
):
    """
    Returns gene IDs for all genes associated with a given phenotype, filtered by taxon
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/genes',
    tags=[
        'gene_association_retrieval',
        'phenotype_association_retrieval',
        'case_association_management',
    ],
)
def get_phenotype_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genes associated with a phenotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/genotypes',
    tags=[
        'case_association_management',
        'gene_association_retrieval',
        'phenotype_association_retrieval',
        'genotype_association_overview',
    ],
)
def get_phenotype_genotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genotypes associated with a phenotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/pathways',
    tags=[
        'pathway_association_retrieval',
        'phenotype_association_retrieval',
        'gene_association_retrieval',
    ],
)
def get_phenotype_pathway_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns pathways associated with a phenotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/publications',
    tags=[
        'publication_association_retrieval',
        'phenotype_association_retrieval',
        'disease_association_retrieval',
    ],
)
def get_phenotype_publication_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns publications associated with a phenotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/phenotype/{id}/variants',
    tags=[
        'variant_association_retrieval',
        'phenotype_association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
    ],
)
def get_phenotype_variant_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns variants associated with a phenotype
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/publication/{id}/diseases',
    tags=['disease_association_retrieval', 'publication_association_retrieval'],
)
def get_publication_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns diseases associated with a publication
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/publication/{id}/genes',
    tags=[
        'gene_association_retrieval',
        'publication_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_publication_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genes associated with a publication
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/publication/{id}/genotypes',
    tags=[
        'publication_association_retrieval',
        'gene_associations_overview',
        'genotype_association_overview',
    ],
)
def get_publication_genotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genotypes associated with a publication
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/publication/{id}/models',
    tags=[
        'model_association_collection',
        'publication_association_retrieval',
        'gene_association_retrieval',
    ],
)
def get_publication_model_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns models associated with a publication
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/publication/{id}/phenotypes',
    tags=[
        'phenotype_association_retrieval',
        'publication_association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
    ],
)
def get_publication_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns phenotypes associated with a publication
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/publication/{id}/variants',
    tags=[
        'variant_association_retrieval',
        'publication_association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
    ],
)
def get_publication_variant_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns variants associated with a publication
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/substance/{id}/participant_in',
    description=""" Examples relationships:

 * substance is a metabolite of a process
 * substance is synthesized by a process
 * substance is modified by an activity
 * substance elicits a response program/pathway
 * substance is transported by activity or pathway

For example, CHEBI:40036 (amitrole) """,
    tags=[
        'association_retrieval',
        'substance_association_details',
        'generic_association_handling',
    ],
)
def get_substance_participant_in_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns associations between an activity and process and the specified substance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/substance/{id}/roles',
    description=""" Roles may be human-oriented (e.g. pesticide) or molecular (e.g. enzyme inhibitor) """,
    tags=['substance_association_details', 'generic_association_handling'],
)
def get_substance_role_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns associations between given drug and roles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/substance/{id}/treats',
    description=""" e.g. drugs or small molecules used to treat """,
    tags=[
        'disease_association_retrieval',
        'substance_association_details',
        'case_association_management',
    ],
)
def get_substance_treats_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns substances associated with a disease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/variant/{id}/cases',
    tags=[
        'case_association_management',
        'variant_association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_variant_case_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns cases associated with a variant
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/variant/{id}/diseases',
    tags=[
        'disease_association_retrieval',
        'variant_association_retrieval',
        'case_association_management',
    ],
)
def get_variant_disease_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns diseases associated with a variant
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/variant/{id}/genes',
    tags=[
        'gene_association_retrieval',
        'variant_association_retrieval',
        'case_association_management',
        'gene_associations_overview',
    ],
)
def get_variant_gene_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genes associated with a variant
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/variant/{id}/genotypes',
    tags=[
        'gene_association_retrieval',
        'genotype_association_overview',
        'variant_association_retrieval',
    ],
)
def get_variant_genotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns genotypes associated with a variant
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/variant/{id}/models',
    tags=[
        'model_association_collection',
        'variant_association_retrieval',
        'gene_associations_overview',
    ],
)
def get_variant_model_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns models associated with a variant
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/variant/{id}/phenotypes',
    tags=[
        'phenotype_association_retrieval',
        'variant_association_retrieval',
        'case_association_management',
    ],
)
def get_variant_phenotype_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns phenotypes associated with a variant
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/variant/{id}/publications',
    tags=['publication_association_retrieval', 'variant_association_retrieval'],
)
def get_variant_publication_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns publications associated with a variant
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/{id}', tags=['generic_association_handling', 'entity_set_operations']
)
def get_generic_object(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    id: str = ...,
):
    """
    Returns basic info on object of any type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/{id}/associations',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
    ],
)
def get_generic_associations(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    taxon: Optional[Taxon1] = None,
    direct_taxon: Optional[bool] = False,
    relation: Optional[str] = None,
    sort: Optional[str] = None,
    q: Optional[str] = None,
    id: str = ...,
):
    """
    Returns associations for an entity regardless of the type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentity/{type}/{id}',
    tags=['generic_association_handling', 'entity_set_operations'],
)
def get_generic_object_by_type(
    rows: Optional[int] = 100,
    start: Optional[int] = None,
    facet: Optional[bool] = False,
    facet_fields: Optional[FacetFields] = None,
    unselect_evidence: Optional[bool] = False,
    exclude_automatic_assertions: Optional[bool] = False,
    fetch_objects: Optional[bool] = False,
    use_compact_associations: Optional[bool] = False,
    slim: Optional[Slim] = None,
    evidence: Optional[str] = None,
    direct: Optional[bool] = False,
    get_association_counts: Optional[bool] = False,
    distinct_counts: Optional[bool] = False,
    type: Type = ...,
    id: str = ...,
):
    """
    Return basic info on an object for a given type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentityset/associations',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
    ],
)
def get_entity_set_associations(
    subject: Optional[Subject] = None,
    background: Optional[Background] = None,
    object_category: Optional[str] = None,
    object_slim: Optional[str] = None,
):
    """
    Returns compact associations for a given input set
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentityset/descriptor/counts',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
        'annotation_summarization_functions',
    ],
)
def get_entity_set_summary(
    subject: Optional[Subject] = None,
    background: Optional[Background] = None,
    object_category: Optional[str] = None,
    object_slim: Optional[str] = None,
):
    """
    Summary statistics for objects associated
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentityset/graph',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'graph_resource_operations',
    ],
)
def get_entity_set_graph_resource(
    subject: Optional[Subject] = None,
    background: Optional[Background] = None,
    object_category: Optional[str] = None,
    object_slim: Optional[str] = None,
):
    """
    TODO Graph object spanning all entities
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentityset/homologs/',
    tags=[
        'gene_association_retrieval',
        'gene_associations_overview',
        'case_association_management',
    ],
)
def get_entity_set_homologs(subject: Optional[Subject] = None):
    """
    Returns homology associations for a given input set of genes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentityset/overrepresentation',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
        'annotation_management_functions',
    ],
)
def get_over_representation(
    object_category: Optional[str] = None,
    subject: Optional[Subject] = None,
    background: Optional[Background] = None,
    subject_category: Optional[str] = 'gene',
    max_p_value: Optional[str] = '0.05',
    ontology: Optional[str] = None,
    taxon: Optional[str] = None,
):
    """
    Summary statistics for objects associated
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentityset/slimmer/anatomy',
    tags=[
        'gene_association_retrieval',
        'gene_associations_overview',
        'annotation_summarization_functions',
    ],
)
def get_entity_set_anatomy_slimmer(
    subject: Subject,
    slim: Slim = ...,
    exclude_automatic_assertions: Optional[bool] = False,
    rows: Optional[int] = 100,
    start: Optional[int] = None,
):
    """
    For a given gene(s), summarize its annotations over a defined set of slim
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentityset/slimmer/function',
    tags=[
        'gene_association_retrieval',
        'annotation_summarization_functions',
        'gene_associations_overview',
    ],
)
def get_entity_set_function_slimmer(
    relationship_type: Optional[RelationshipType4] = 'acts_upstream_of_or_within',
    subject: Subject = ...,
    slim: Slim = ...,
    exclude_automatic_assertions: Optional[bool] = False,
    rows: Optional[int] = 100,
    start: Optional[int] = None,
):
    """
    For a given gene(s), summarize its annotations over a defined set of slim
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/bioentityset/slimmer/phenotype',
    tags=[
        'gene_association_retrieval',
        'annotation_summarization_functions',
        'gene_associations_overview',
    ],
)
def get_entity_set_phenotype_slimmer(
    subject: Subject,
    slim: Slim = ...,
    exclude_automatic_assertions: Optional[bool] = False,
    rows: Optional[int] = 100,
    start: Optional[int] = None,
):
    """
    For a given gene(s), summarize its annotations over a defined set of slim
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/activity',
    tags=['model_management_operations', 'model_association_collection'],
)
def get_activity_collection(
    title: Optional[str] = None, contributor: Optional[str] = None
):
    """
    Returns list of models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/instance/{id}', tags=['generic_association_handling', 'entity_set_operations']
)
def get_instance_object(
    title: Optional[str] = None, contributor: Optional[str] = None, id: str = ...
):
    """
    Returns list of matches
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/instances',
    tags=[
        'generic_association_handling',
        'entity_set_operations',
        'model_management_operations',
    ],
)
def get_model_instances():
    """
    Returns list of all instances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/model', tags=['model_management_operations', 'generic_association_handling']
)
def get_model_collection():
    """
    Returns list of ALL models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/model/contributors',
    tags=['model_management_operations', 'generic_association_handling'],
)
def get_model_contributors():
    """
    Returns list of all contributors across all models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/model/properties',
    tags=['model_management_operations', 'generic_association_handling'],
)
def get_model_properties(
    title: Optional[str] = None, contributor: Optional[str] = None
):
    """
    Returns list of all properties used across all models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/model/property_values',
    tags=[
        'model_management_operations',
        'generic_association_handling',
        'entity_set_operations',
    ],
)
def get_model_property_values(
    title: Optional[str] = None, contributor: Optional[str] = None
):
    """
    Returns list property-values for all models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/model/query',
    tags=['model_management_operations', 'generic_association_handling'],
)
def get_model_query(title: Optional[str] = None, contributor: Optional[str] = None):
    """
    Returns list of models matching query
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/model/{id}',
    tags=['model_management_operations', 'model_association_collection'],
)
def get_model_object(id: str):
    """
    Returns a complete model
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cam/physical_interaction',
    tags=['model_association_collection', 'model_management_operations'],
)
def get_physical_interaction(
    title: Optional[str] = None, contributor: Optional[str] = None
):
    """
    Returns list of models
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/evidence/graph/{id}',
    description=""" Note that every association is assumed to have a unique ID """,
    tags=[
        'association_retrieval',
        'gene_association_retrieval',
        'disease_association_retrieval',
        'generic_association_handling',
        'graph_resource_operations',
    ],
)
def get_evidence_graph_object(id: str):
    """
    Returns evidence graph object for a given association
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/evidence/graph/{id}/table',
    description=""" Note that every association is assumed to have a unique ID """,
    tags=[
        'association_retrieval',
        'publication_association_retrieval',
        'gene_association_retrieval',
    ],
)
def get_evidence_graph_table(is_publication: Optional[bool] = False, id: str = ...):
    """
    Returns evidence as a association_results object given an association
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/genome/features/within/{build}/{reference}/{begin}/{end}',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'entity_set_operations',
    ],
)
def get_features_within_resource(
    build: str, reference: str = ..., begin: str = ..., end: str = ...
):
    """
    Returns list of matches
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/graph/edges/from/{id}',
    tags=['graph_resource_operations', 'generic_association_handling'],
)
def get_edge_resource(
    depth: Optional[int] = 1,
    direction: Optional[Direction] = 'BOTH',
    relationship_type: Optional[RelationshipType6] = None,
    entail: Optional[bool] = False,
    graph: Optional[Graph1] = 'data',
    id: str = ...,
):
    """
    Returns edges emanating from a given node
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/graph/node/{id}',
    description=""" A node is an abstract representation of some kind of entity. The entity may be a physical thing such as a patient,
a molecular entity such as a gene or protein, or a conceptual entity such as a class from an ontology. """,
    tags=['graph_resource_operations', 'generic_association_handling'],
)
def get_node_resource(id: str):
    """
    Returns a graph node
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/identifier/mapper/{source}/{target}/',
    tags=['identifier_mapping_functions', 'generic_association_handling'],
)
def get_identifier_mapper(source: str, target: str = ...):
    """
    TODO maps a list of identifiers from a source to a target
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/identifier/prefixes/',
    tags=['identifier_mapping_functions', 'generic_association_handling'],
)
def get_prefix_collection():
    """
    Returns list of prefixes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/identifier/prefixes/contract/{uri}',
    tags=['identifier_mapping_functions', 'generic_association_handling'],
)
def get_prefix_contract(uri: str):
    """
    Returns contracted URI
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/identifier/prefixes/expand/{id}', tags=['identifier_mapping_functions'])
def get_prefix_expand(id: str):
    """
    Returns expanded URI
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/individual/pedigree/{id}',
    tags=['association_retrieval', 'generic_association_handling'],
)
def get_pedigree(id: str):
    """
    Returns list of matches
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/individual/{id}', tags=['generic_association_handling', 'entity_set_operations']
)
def get_individual(id: str):
    """
    Returns list of matches
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/mart/case/{object_category}/{taxon}',
    description=""" NOTE: this route has a limiter on it, you may be restricted in the number of downloads per hour. Use carefully. """,
    tags=['case_association_management', 'case_associations_bulk_management'],
)
def get_mart_case_associations_resource(
    slim: Optional[Slim] = None, taxon: str = ..., object_category: str = ...
):
    """
    Bulk download of case associations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/mart/disease/{object_category}/{taxon}',
    description=""" NOTE: this route has a limiter on it, you may be restricted in the number of downloads per hour. Use carefully. """,
    tags=['disease_association_data_downloads', 'disease_association_retrieval'],
)
def get_mart_disease_associations_resource(
    slim: Optional[Slim] = None, taxon: str = ..., object_category: str = ...
):
    """
    Bulk download of disease associations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/mart/gene/{object_category}/{taxon}',
    description=""" NOTE: this route has a limiter on it, you may be restricted in the number of downloads per hour. Use carefully. """,
    tags=[
        'gene_association_retrieval',
        'gene_associations_overview',
        'disease_association_data_downloads',
    ],
)
def get_mart_gene_associations_resource(
    slim: Optional[Slim] = None, taxon: str = ..., object_category: str = ...
):
    """
    Bulk download of gene associations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/mart/ortholog/{taxon1}/{taxon2}',
    tags=['gene_association_retrieval', 'disease_association_data_downloads'],
)
def get_mart_ortholog_associations_resource(taxon2: str, taxon1: str = ...):
    """
    Bulk download of orthologs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/mart/paralog/{taxon1}/{taxon2}',
    tags=['disease_association_data_downloads', 'gene_association_retrieval'],
)
def get_mart_paralog_associations_resource(taxon2: str, taxon1: str = ...):
    """
    Bulk download of paralogs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/metadata/datasets',
    tags=['graph_resource_operations', 'generic_association_handling'],
)
def get_metadata_for_datasets():
    """
    Get metadata for all datasets from SciGraph
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/mme/disease',
    tags=[
        'case_association_management',
        'disease_association_retrieval',
        'phenotype_association_retrieval',
    ],
)
def post_disease_mme(body: Mme):
    """
    Match a patient to diseases based on their phenotypes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/mme/fly',
    tags=[
        'case_association_management',
        'patient_gene_matching_functions',
        'phenotype_association_retrieval',
        'gene_association_retrieval',
    ],
)
def post_fly_mme(body: Mme):
    """
    Match a patient to fruit fly genes based on similar phenotypes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/mme/mouse',
    tags=[
        'case_association_management',
        'patient_gene_matching_functions',
        'phenotype_association_retrieval',
        'gene_association_retrieval',
    ],
)
def post_mouse_mme(body: Mme):
    """
    Match a patient to mouse genes based on similar phenotypes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/mme/nematode',
    tags=[
        'case_association_management',
        'gene_association_retrieval',
        'phenotype_association_retrieval',
        'patient_gene_matching_functions',
    ],
)
def post_nematode_mme(body: Mme):
    """
    Match a patient to nematode genes based on similar phenotypes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/mme/zebrafish',
    tags=[
        'case_association_management',
        'gene_association_retrieval',
        'phenotype_association_retrieval',
        'patient_gene_matching_functions',
    ],
)
def post_zebrafish_mme(body: Mme):
    """
    Match a patient to zebrafish genes based on similar phenotypes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nlp/annotate/',
    tags=['text_annotation_functions', 'annotation_management_functions'],
)
def get_annotate(
    content: Optional[str] = None,
    include_category: Optional[IncludeCategory] = None,
    exclude_category: Optional[ExcludeCategory] = None,
    min_length: Optional[str] = 4,
    longest_only: Optional[bool] = False,
    include_abbreviation: Optional[bool] = False,
    include_acronym: Optional[bool] = False,
    include_numbers: Optional[bool] = False,
):
    """
    Annotate a given text using SciGraph annotator
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/nlp/annotate/',
    tags=['text_annotation_functions', 'annotation_management_functions'],
)
def post_annotate(
    content: Optional[str] = None,
    include_category: Optional[IncludeCategory] = None,
    exclude_category: Optional[ExcludeCategory] = None,
    min_length: Optional[str] = 4,
    longest_only: Optional[bool] = False,
    include_abbreviation: Optional[bool] = False,
    include_acronym: Optional[bool] = False,
    include_numbers: Optional[bool] = False,
):
    """
    Annotate a given text using SciGraph annotator
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/nlp/annotate/entities',
    tags=[
        'text_annotation_functions',
        'generic_association_handling',
        'annotation_management_functions',
    ],
)
def get_annotate_entities(
    content: Optional[str] = None,
    include_category: Optional[IncludeCategory] = None,
    exclude_category: Optional[ExcludeCategory] = None,
    min_length: Optional[str] = 4,
    longest_only: Optional[bool] = False,
    include_abbreviation: Optional[bool] = False,
    include_acronym: Optional[bool] = False,
    include_numbers: Optional[bool] = False,
):
    """
    Annotate a given content using SciGraph annotator and get all entities from content
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/nlp/annotate/entities',
    tags=[
        'text_annotation_functions',
        'annotation_management_functions',
        'generic_association_handling',
    ],
)
def post_annotate_entities(
    content: Optional[str] = None,
    include_category: Optional[IncludeCategory] = None,
    exclude_category: Optional[ExcludeCategory] = None,
    min_length: Optional[str] = 4,
    longest_only: Optional[bool] = False,
    include_abbreviation: Optional[bool] = False,
    include_acronym: Optional[bool] = False,
    include_numbers: Optional[bool] = False,
):
    """
    Annotate a given content using SciGraph annotator and get all entities from content
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontol/identifier/',
    tags=['identifier_mapping_functions', 'generic_association_handling'],
)
def get_ontol_identifier_resource(label: Label):
    """
    Fetches a map from CURIEs/IDs to labels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ontol/identifier/',
    description=""" Takes 'label' list argument either as a querystring argument or as a key
in the POST body when content-type is application/json. """,
    tags=['identifier_mapping_functions', 'generic_association_handling'],
)
def post_ontol_identifier_resource(label: Label):
    """
    Fetches a map from CURIEs/IDs to labels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontol/information_content/{subject_category}/{object_category}/{subject_taxon}',
    description=""" ```
IC = -log2( freq(t) / popSize )
```

Here the frequency and population is calculated for a particular dataset:
e.g. all human disease-phenotype associations """,
    tags=[
        'ontology_data_management',
        'association_retrieval',
        'generic_association_handling',
    ],
)
def get_information_content_resource(
    evidence: Optional[str] = None,
    subject_category: str = ...,
    object_category: str = ...,
    subject_taxon: str = ...,
):
    """
    Returns information content (IC) for a set of relevant ontology classes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontol/labeler/',
    tags=['identifier_mapping_functions', 'generic_association_handling'],
)
def get_ontol_labeler_resource(id: Id):
    """
    Fetches a map from CURIEs/IDs to labels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontol/subgraph/{ontology}/{node}',
    tags=['ontology_data_management', 'graph_resource_operations'],
)
def get_extract_ontology_subgraph_resource(
    cnode: Optional[Cnode] = None,
    include_ancestors: Optional[bool] = True,
    include_descendants: Optional[bool] = None,
    relation: Optional[Relation1] = ['subClassOf', 'BFO:0000050'],
    include_meta: Optional[bool] = False,
    node: str = ...,
    ontology: str = ...,
):
    """
    Extract a subgraph from an ontology
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ontol/subgraph/{ontology}/{node}',
    tags=['ontology_data_management', 'graph_resource_operations'],
)
def post_extract_ontology_subgraph_resource(
    cnode: Optional[Cnode] = None,
    include_ancestors: Optional[bool] = True,
    include_descendants: Optional[bool] = None,
    relation: Optional[Relation1] = ['subClassOf', 'BFO:0000050'],
    include_meta: Optional[bool] = False,
    node: str = ...,
    ontology: str = ...,
):
    """
    Extract a subgraph from an ontology
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontology/shared/{subject}/{object}',
    tags=[
        'ontology_data_management',
        'generic_association_handling',
        'association_retrieval',
    ],
)
def get_ontology_terms_shared_ancestor(subject: str, object: str = ...):
    """
    Returns the ancestor ontology terms shared by two ontology terms
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontology/subset/{id}',
    tags=['ontology_data_management', 'annotation_summarization_functions'],
)
def get_ontology_subset(id: str):
    """
    Returns meta data of an ontology subset (slim)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/ontology/term/{id}', tags=['ontology_data_management'])
def get_ontology_term(id: str):
    """
    Returns meta data of an ontology term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontology/term/{id}/graph',
    tags=['ontology_data_management', 'graph_resource_operations'],
)
def get_ontology_term_graph(
    graph_type: Optional[GraphType] = 'topology_graph', id: str = ...
):
    """
    Returns graph of an ontology term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontology/term/{id}/subgraph',
    tags=['ontology_data_management', 'graph_resource_operations'],
)
def get_ontology_term_subgraph(
    cnode: Optional[Cnode] = None,
    include_ancestors: Optional[bool] = True,
    include_descendants: Optional[bool] = None,
    relation: Optional[Relation1] = ['subClassOf', 'BFO:0000050'],
    include_meta: Optional[bool] = False,
    id: str = ...,
):
    """
    Extract a subgraph from an ontology term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ontology/term/{id}/subsets',
    tags=[
        'go_term_association_retrieval',
        'ontology_data_management',
        'annotation_summarization_functions',
    ],
)
def get_ontology_term_subsets(id: str):
    """
    Returns subsets (slims) associated to an ontology term
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/owl/ontology/dlquery/{query}',
    tags=['generic_association_handling', 'concept_search_functions'],
)
def get_dl_query(query: str):
    """
    Placeholder - use OWLery for now
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/owl/ontology/sparql/{query}',
    tags=['generic_association_handling', 'graph_resource_operations'],
)
def get_sparql_query(query: str):
    """
    Placeholder - use direct SPARQL endpoint for now
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pair/sim/jaccard/{id1}/{id2}',
    tags=[
        'similarity_analysis_functions',
        'similarity_comparison_functions',
        'generic_association_handling',
    ],
)
def get_pair_sim_jaccard_resource(
    object_category: Optional[str] = None, id2: str = ..., id1: str = ...
):
    """
    Get pairwise similarity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/relation/usage/',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'relation_usage_metrics_functions',
    ],
)
def get_relation_usage_resource(
    subject_taxon: Optional[str] = None, evidence: Optional[str] = None
):
    """
    All relations used plus count of associations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/relation/usage/between/{subject_category}/{object_category}',
    tags=[
        'association_retrieval',
        'generic_association_handling',
        'relation_usage_metrics_functions',
    ],
)
def get_relation_usage_between_resource(
    subject_taxon: Optional[str] = None,
    evidence: Optional[str] = None,
    subject_category: str = ...,
    object_category: str = ...,
):
    """
    All relations used plus count of associations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/relation/usage/pivot',
    tags=['relation_usage_metrics_functions', 'association_retrieval'],
)
def get_relation_usage_pivot_resource(
    subject_taxon: Optional[str] = None, evidence: Optional[str] = None
):
    """
    Relation usage count for all subj x obj category combinations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/relation/usage/pivot/label',
    tags=[
        'association_retrieval',
        'relation_usage_metrics_functions',
        'generic_association_handling',
    ],
)
def get_relation_usage_pivot_label_resource(
    subject_taxon: Optional[str] = None, evidence: Optional[str] = None
):
    """
    Relation usage count for all subj x obj category combinations, showing label
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/entity/autocomplete/{term}',
    tags=['concept_search_functions', 'generic_association_handling'],
)
def get_autocomplete(
    fq: Optional[Fq] = None,
    category: Optional[Category] = None,
    prefix: Optional[Prefix] = None,
    include_eqs: Optional[bool] = False,
    boost_fx: Optional[BoostFx] = None,
    boost_q: Optional[BoostQ] = None,
    taxon: Optional[Taxon1] = None,
    rows: Optional[int] = 20,
    start: Optional[str] = '0',
    highlight_class: Optional[str] = None,
    min_match: Optional[str] = None,
    exclude_groups: Optional[bool] = False,
    minimal_tokenizer: Optional[bool] = False,
    term: str = ...,
):
    """
    Returns list of matching concepts or entities using lexical search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/entity/hpo-pl/{term}',
    tags=[
        'concept_search_functions',
        'association_retrieval',
        'generic_association_handling',
    ],
)
def get_search_hpo_entities(
    rows: Optional[int] = 10,
    start: Optional[str] = '0',
    phenotype_group: Optional[str] = None,
    phenotype_group_label: Optional[str] = None,
    anatomical_system: Optional[str] = None,
    anatomical_system_label: Optional[str] = None,
    highlight_class: Optional[str] = None,
    term: str = ...,
):
    """
    Returns list of matching concepts or entities using lexical search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/search/entity/{term}',
    tags=['concept_search_functions', 'generic_association_handling'],
)
def get_search_entities(
    fq: Optional[Fq] = None,
    category: Optional[Category] = None,
    prefix: Optional[Prefix] = None,
    include_eqs: Optional[bool] = False,
    boost_fx: Optional[BoostFx] = None,
    boost_q: Optional[BoostQ] = None,
    taxon: Optional[Taxon1] = None,
    rows: Optional[int] = 20,
    start: Optional[str] = '0',
    highlight_class: Optional[str] = None,
    min_match: Optional[str] = None,
    exclude_groups: Optional[bool] = False,
    minimal_tokenizer: Optional[bool] = False,
    term: str = ...,
):
    """
    Returns list of matching concepts or entities using lexical search
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim/compare',
    tags=['similarity_analysis_functions', 'similarity_comparison_functions'],
)
def get_sim_compare(
    is_feature_set: Optional[bool] = True,
    metric: Optional[Metric] = 'phenodigm',
    ref_id: Optional[RefId] = [],
    query_id: Optional[QueryId] = [],
):
    """
    Compare a reference profile vs one profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim/compare',
    tags=[
        'similarity_comparison_functions',
        'gene_association_retrieval',
        'generic_association_handling',
    ],
)
def post_sim_compare(body: CompareInput):
    """
    Compare a reference profile vs one or more profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim/score',
    tags=['annotation_management_functions', 'annotation_summarization_functions'],
)
def get_annotation_score(id: Optional[Id] = None, absent_id: Optional[AbsentId] = []):
    """
    Get annotation score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/sim/score',
    tags=['annotation_management_functions', 'annotation_summarization_functions'],
)
def post_annotation_score(body: SufficiencyPostInput):
    """
    Get annotation score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sim/search',
    tags=[
        'association_retrieval',
        'case_association_management',
        'disease_association_retrieval',
        'phenotype_association_retrieval',
        'similarity_analysis_functions',
    ],
)
def get_sim_search(
    is_feature_set: Optional[bool] = True,
    metric: Optional[Metric] = 'phenodigm',
    id: Optional[Id] = [],
    limit: Optional[int] = 20,
    taxon: Optional[str] = None,
):
    """
    Search for phenotypically similar diseases or model genes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/variation/set/',
    tags=['variant_association_retrieval', 'variant_sets_management_functions'],
)
def get_variant_sets_collection(
    page: Optional[int] = 1, per_page: Optional[PerPage] = 10
):
    """
    Returns list of variant sets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/variation/set/', tags=['variant_sets_management_functions'])
def post_variant_sets_collection(body: VariantSet):
    """
    Creates a new variant set
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/variation/set/analyze/{id}',
    tags=['generic_association_handling', 'entity_set_operations'],
)
def get_variant_analyze(id: str):
    """
    Returns list of matches
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/variation/set/archive/{year}/{month}/{day}',
    tags=['variant_association_retrieval', 'variant_sets_management_functions'],
)
def get_variant_sets_archive_collection(
    page: Optional[int] = 1,
    per_page: Optional[PerPage] = 10,
    year: int = ...,
    month: int = ...,
    day: int = ...,
):
    """
    Returns list of variant sets from a specified time period
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/variation/set/{id}', tags=['variant_sets_management_functions'])
def delete_variant_set_item(id: str):
    """
    Deletes variant set
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/variation/set/{id}',
    tags=['variant_association_retrieval', 'variant_sets_management_functions'],
)
def get_variant_set_item(id: str):
    """
    Returns a variant set
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put('/variation/set/{id}', tags=['variant_sets_management_functions'])
def put_variant_set_item(id: str, body: VariantSet = ...):
    """
    Updates a variant set
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
